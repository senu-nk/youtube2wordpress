#!/usr/bin/env python3
"""Upload local media assets to Cloudflare R2 using S3-compatible APIs.

This uploader relies on pre-signed PUT URLs generated by boto3, then performs
the actual uploads with ``requests`` while forcing TLS 1.2 for compatibility
with hosts that fail the default TLS 1.3 handshake against Cloudflare R2.
"""
from __future__ import annotations

import argparse
import mimetypes
import os
import ssl
import sys
from pathlib import Path

import boto3
import requests
from botocore.config import Config
from botocore.exceptions import BotoCoreError
from requests.adapters import HTTPAdapter
from urllib3 import PoolManager


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Upload files from a directory to Cloudflare R2.")
    parser.add_argument("source", type=Path, help="Directory containing files to upload")
    return parser.parse_args()


def require_env(name: str) -> str:
    value = os.getenv(name, "").strip()
    if not value:
        raise RuntimeError(f"Environment variable {name} is required for R2 uploads")
    return value


def iter_files(root: Path) -> list[Path]:
    return [path for path in sorted(root.rglob("*")) if path.is_file()]


def build_key(root: Path, path: Path, prefix: str) -> str:
    relative = path.relative_to(root).as_posix()
    if prefix:
        return f"{prefix}/{relative}"
    return relative


def guess_content_type(path: Path) -> str | None:
    mime_type, _ = mimetypes.guess_type(path.name)
    return mime_type


def resolve_verify_setting(raw: str) -> bool | str:
    setting = raw.strip().lower()
    if setting in {"0", "false", "no"}:
        return False
    if setting in {"1", "true", "yes", ""}:
        return True
    return raw.strip()


def create_tls_context(force_tls12: bool, cipher_override: str | None, *, verify: bool = True, ca_path: str | None = None) -> ssl.SSLContext:
    """Build an SSLContext honoring TLS1.2/cipher preferences and verification.

    If verify is False, hostname verification is disabled and CERT_NONE is set
    to avoid ValueError raised by urllib3 when toggling modes.
    """
    context = ssl.create_default_context()
    if force_tls12:
        if hasattr(ssl, "TLSVersion"):
            context.minimum_version = ssl.TLSVersion.TLSv1_2
            context.maximum_version = ssl.TLSVersion.TLSv1_2
        else:  # pragma: no cover - legacy Python fallback
            context.options |= getattr(ssl, "OP_NO_TLSv1", 0)
            context.options |= getattr(ssl, "OP_NO_TLSv1_1", 0)
    if cipher_override:
        try:
            context.set_ciphers(cipher_override)
        except ssl.SSLError as err:
            raise RuntimeError(f"Invalid cipher suite override '{cipher_override}': {err}") from err
    context.options |= getattr(ssl, "OP_NO_COMPRESSION", 0)

    if not verify:
        context.check_hostname = False
        context.verify_mode = ssl.CERT_NONE
    elif ca_path:
        # Use custom CA bundle if provided
        try:
            context.load_verify_locations(cafile=ca_path)
        except Exception as err:  # noqa: BLE001
            raise RuntimeError(f"Failed to load CA bundle from {ca_path}: {err}") from err
    return context


class TLS12Adapter(HTTPAdapter):
    """HTTP adapter that forces TLS settings compatible with Cloudflare R2."""

    def __init__(self, *, force_tls12: bool, cipher_override: str | None = None, verify: bool = True, ca_path: str | None = None, **kwargs) -> None:
        self._force_tls12 = force_tls12
        self._cipher_override = cipher_override
        self._verify = verify
        self._ca_path = ca_path
        super().__init__(**kwargs)

    def init_poolmanager(self, connections: int, maxsize: int, block: bool = False, **pool_kwargs) -> None:
        context = create_tls_context(self._force_tls12, self._cipher_override, verify=self._verify, ca_path=self._ca_path)
        pool_kwargs.setdefault("ssl_context", context)
        if not self._verify:
            pool_kwargs.setdefault("assert_hostname", False)
        self.poolmanager = PoolManager(num_pools=connections, maxsize=maxsize, block=block, **pool_kwargs)

    def proxy_manager_for(self, proxy: str, **proxy_kwargs):  # type: ignore[override]
        context = create_tls_context(self._force_tls12, self._cipher_override, verify=self._verify, ca_path=self._ca_path)
        proxy_kwargs.setdefault("ssl_context", context)
        if not self._verify:
            proxy_kwargs.setdefault("assert_hostname", False)
        return super().proxy_manager_for(proxy, **proxy_kwargs)


def build_s3_client(access_key: str, secret_key: str, region: str, endpoint: str, addressing_style: str, verify: bool | str):
    session = boto3.session.Session(
        aws_access_key_id=access_key,
        aws_secret_access_key=secret_key,
        region_name=region,
    )
    config = Config(signature_version="s3v4", s3={"addressing_style": addressing_style or "path"})
    return session.client("s3", endpoint_url=endpoint, config=config, verify=verify)


def upload_via_presigned(client, session: requests.Session, bucket: str, key: str, path: Path, content_type: str | None) -> None:
    params: dict[str, str] = {"Bucket": bucket, "Key": key}
    headers: dict[str, str] = {}
    if content_type:
        params["ContentType"] = content_type
        headers["Content-Type"] = content_type
    cache_control = os.getenv("R2_CACHE_CONTROL", "public, max-age=31536000, immutable")
    if cache_control:
        params["CacheControl"] = cache_control
        headers["Cache-Control"] = cache_control

    try:
        url = client.generate_presigned_url("put_object", Params=params, ExpiresIn=3600)
    except BotoCoreError as err:
        raise RuntimeError(f"Failed to build presigned URL for {bucket}/{key}: {err}") from err

    with path.open("rb") as handle:
        response = session.put(url, data=handle, headers=headers)
    if response.status_code >= 400:
        raise RuntimeError(
            f"Failed to upload {path} to {bucket}/{key}: {response.status_code} {response.text.strip()}"
        )


def upload_via_presigned_with_fallback(
    client,
    primary: requests.Session,
    fallback: requests.Session | None,
    bucket: str,
    key: str,
    path: Path,
    content_type: str | None,
) -> None:
    try:
        upload_via_presigned(client, primary, bucket, key, path, content_type)
        return
    except requests.exceptions.SSLError as err:
        if not fallback:
            raise
        # Retry once with fallback TLS settings
        upload_via_presigned(client, fallback, bucket, key, path, content_type)


def upload_directory(root: Path) -> None:
    if not root.exists() or not root.is_dir():
        raise RuntimeError(f"Source directory not found: {root}")

    access_key = require_env("R2_ACCESS_KEY_ID")
    secret_key = require_env("R2_SECRET_ACCESS_KEY")
    endpoint = require_env("R2_ENDPOINT_URL")
    bucket = require_env("R2_BUCKET")
    region = os.getenv("R2_REGION", "auto")
    prefix = os.getenv("R2_UPLOAD_PREFIX", "").strip("/")
    addressing_style = os.getenv("R2_ADDRESSING_STYLE", "path").strip().lower()
    verify_setting = resolve_verify_setting(os.getenv("R2_VERIFY_SSL", "1"))
    force_tls12 = os.getenv("R2_FORCE_TLS12", "1").strip().lower() not in {"0", "false", "no"}
    cipher_override = os.getenv("R2_TLS_CIPHERS", "").strip() or (
        "ECDHE-ECDSA-AES128-GCM-SHA256:" \
        "ECDHE-RSA-AES128-GCM-SHA256:" \
        "ECDHE-ECDSA-AES256-GCM-SHA384:" \
        "ECDHE-RSA-AES256-GCM-SHA384"
    )

    client = build_s3_client(access_key, secret_key, region, endpoint, addressing_style, verify_setting)

    # Build primary session that negotiates TLS normally (allows TLS 1.3 if available)
    primary_session = requests.Session()
    if isinstance(verify_setting, (bool, str)):
        primary_session.verify = verify_setting

    # Build fallback session that forces TLS 1.2 and compatible ciphers
    fallback_session = requests.Session()
    if isinstance(verify_setting, bool):
        adapter = TLS12Adapter(force_tls12=True, cipher_override=cipher_override, verify=verify_setting)
        fallback_session.mount("https://", adapter)
        fallback_session.verify = verify_setting
    else:
        adapter = TLS12Adapter(force_tls12=True, cipher_override=cipher_override, verify=True, ca_path=verify_setting)
        fallback_session.mount("https://", adapter)
        fallback_session.verify = verify_setting

    files = iter_files(root)
    if not files:
        print(f"No files to upload in {root}")
        return

    for path in files:
        key = build_key(root, path, prefix)
        content_type = guess_content_type(path)
        try:
            upload_via_presigned_with_fallback(
                client,
                primary_session,
                fallback_session,
                bucket,
                key,
                path,
                content_type,
            )
        except RuntimeError as err:
            raise RuntimeError(str(err)) from err
        print(f"Uploaded {path.name} -> {bucket}/{key}")


def main() -> None:
    try:
        args = parse_args()
        upload_directory(args.source)
    except RuntimeError as err:
        print(str(err), file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
